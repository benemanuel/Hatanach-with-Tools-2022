"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Cluster_original, _Cluster_sequenced;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cluster = void 0;
const char_1 = require("./char");
const node_1 = require("./node");
const regularExpressions_1 = require("./utils/regularExpressions");
/**
 * A cluster is group of Hebrew character constituted by:
 * - an obligatory Hebrew consonant character
 * - an optional ligature mark
 * - an optional vowel
 * - an optional taam
 *
 * A [[`Syllable`]] is a linguistic unit, whereas a `Cluster` is an orthgraphic one.
 * The word `??????????` is only one syllable, but it has three clusters???`????`, `????`, `??`.
 * Because Hebrew orthography is both sub and supra linear, clusters can be encoded in various ways.
 * Every [[`Char`]] is sequenced first for normalization, see the [SBL Hebrew Font Manual](https://www.sbl-site.org/Fonts/SBLHebrewUserManual1.5x.pdf), p.8.
 */
class Cluster extends node_1.Node {
    constructor(cluster) {
        super();
        _Cluster_original.set(this, void 0);
        _Cluster_sequenced.set(this, void 0);
        __classPrivateFieldSet(this, _Cluster_original, cluster, "f");
        __classPrivateFieldSet(this, _Cluster_sequenced, this.sequence(), "f");
    }
    /**
     * @returns the original string passed
     */
    get original() {
        return __classPrivateFieldGet(this, _Cluster_original, "f");
    }
    /**
     * @returns a string that has been built up from the text of its consituent Chars
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * const clusters = text.clusters.map((cluster) => cluster.text);
     * // [
     * //  "????",
     * //  "????",
     * //  "????",
     * //  "??",
     * //  "??"
     * // ]
     * ```
     */
    get text() {
        return this.chars.reduce((init, char) => init + char.text, "");
    }
    /**
     * @returns an array of sequenced Char objects
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].chars;
     * // [
     * //  Char { original: "??" },
     * //  Char { original: "?? " },   i.e. \u{05B2} (does not print well)
     * // ]
     * ```
     */
    get chars() {
        return __classPrivateFieldGet(this, _Cluster_sequenced, "f");
    }
    sequence() {
        return [...this.original].map((char) => new char_1.Char(char)).sort((a, b) => a.sequencePosition - b.sequencePosition);
    }
    /**
     * Returns `true` if one of the following long vowel characters is present:
     * - \u{05B5} TSERE
     * - \u{05B8} QAMATS
     * - \u{05B9} HOLAM
     * - \u{05BA} HOLAM HASER FOR VAV
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasLongVowel;
     * // false
     * text.clusters[1].hasLongVowel;
     * // true
     * ```
     */
    get hasLongVowel() {
        return /[\u{05B5}\u{05B8}\u{05B9}\u{05BA}]/u.test(this.text);
    }
    /**
     * Returns `true` if one of the following long vowel characters is present:
     * - \u{05B4} HIRIQ
     * - \u{05B6} SEGOL
     * - \u{05B7} PATAH
     * - \u{05BB} QUBUTS
     * - \u{05C7} QAMATS QATAN
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasShortVowel;
     * // true
     * text.clusters[2].hasShortVowel;
     * // false
     * ```
     */
    get hasShortVowel() {
        return /[\u{05B4}\u{05B6}\u{05B7}\u{05BB}\u{05C7}]/u.test(this.text);
    }
    /**
     *
     * Returns `true` if one of the following long vowel characters is present:
     * - \u{05B1} HATAF SEGOL
     * - \u{05B2} HATAF PATAH
     * - \u{05B3} HATAF QAMATS
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasHalfVowel;
     * // true
     * text.clusters[1].hasHalfVowel;
     * // false
     * ```
     */
    get hasHalfVowel() {
        return /[\u{05B1}-\u{05B3}]/u.test(this.text);
    }
    /**
     * Returns `true` if `Cluster.hasLongVowel`, `Cluster.hasShortVowel`, or `Cluster.hasHalfVowel` is true.
     *
     * According to {@page Syllabification}, a shewa is a vowel and serves as the nucleus of a syllable.
     * Because `Cluster` is concerned with orthography, a shewa is **not** a vowel character.
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasVowel;
     * // true
     * text.clusters[4].hasVowel;
     * // false
     * ```
     */
    get hasVowel() {
        return this.hasLongVowel || this.hasShortVowel || this.hasHalfVowel;
    }
    /**
     *
     * Returns `true` if `Cluster.hasVowel` is `false` and `Cluster.text` is a waw followed by a dagesh (e.g. `????`)
     * A shureq is a vowel itself, but contains no vowel characters (hence why `hasVowel` cannot be `true`).
     * This allows for easier syllabification.
     *
     * ```typescript
     * const text: Text = new Text("????????");
     * text.clusters[0].isShureq;
     * // false
     * text.clusters[1].isShureq;
     * // true
     * ```
     */
    get isShureq() {
        const shureq = /\u{05D5}\u{05BC}/u;
        return !this.hasVowel ? shureq.test(this.text) : false;
    }
    /**
     * Returns `true` if `Cluster.hasVowel`, `Cluster.hasShewa`, and, `Cluster.isShureq` are all `false` and `Cluster.text` contains a:
     * - `??` preceded by a qamets, tsere, or seghol
     * - `??` preceded by a holem
     * - `??` preceded by a hiriq, tsere, or seghol
     *
     * There are potentially other instances when a consonant may be a _mater_ (e.g. a silent aleph), but these are the most common.
     * Though a shureq is a _mater_ letter, it is also a vowel itself, and thus separate from `isMater`.
     *
     * ```typescript
     * const text: Text = new Text("????????????");
     * text.clusters[1].isMater; // the shureq
     * // false
     * text.clusters[3].isMater; // the heh
     * // true
     * ```
     */
    get isMater() {
        const nxtIsShureq = this.next instanceof Cluster ? this.next.isShureq : false;
        if (!this.hasVowel && !this.isShureq && !this.hasShewa && !nxtIsShureq) {
            const text = this.text;
            const prevText = this.prev instanceof Cluster ? this.prev.text : "";
            const maters = /[??????](?!\u{05BC})/u;
            if (!maters.test(text)) {
                return false;
            }
            if (/??/.test(text) && /\u{05B8}|\u{05B6}|\u{05B5}/u.test(prevText)) {
                return true;
            }
            if (/??/.test(text) && /\u{05B9}/u.test(prevText)) {
                return true;
            }
            if (/??/.test(text) && /\u{05B4}|\u{05B5}|\u{05B6}/u.test(prevText)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns `true` if the following character is present and a _sof pasuq_ does not follow it:
     * - \u{05BD} METEG
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasMetheg;
     * // false
     * ```
     */
    get hasMetheg() {
        const metheg = /\u{05BD}/u;
        const text = this.text;
        if (!metheg.test(text)) {
            return false;
        }
        let next = this.next;
        while (next) {
            if (next instanceof Cluster) {
                const nextText = next.text;
                const sofPassuq = /\u{05C3}/u;
                if (metheg.test(nextText)) {
                    return true;
                }
                if (sofPassuq.test(nextText)) {
                    return false;
                }
                next = next.next;
            }
        }
        return true;
    }
    /**
     * Returns `true` if the following character is present:
     * - \u{05B0} SHEWA
     *
     * ```typescript
     * const text: Text = new Text("????????????????");
     * text.clusters[0].hasShewa;
     * // false
     * text.clusters[1].hasShewa;
     * // true
     * ```
     */
    get hasShewa() {
        return /\u{05B0}/u.test(this.text);
    }
    /**
     * Returns `true` if the following characters are present:
     * - \u{0591}-\u{05AF}\u{05BF}\u{05C0}\u{05C3}-\u{05C6}\u{05F3}\u{05F4}
     *
     * ```typescript
     * const text: Text = new Text("??????????????????");
     * text.clusters[0].hasTaamim;
     * // false
     * text.clusters[2].hasTaamim;
     * // true
     * ```
     */
    get hasTaamim() {
        return regularExpressions_1.taamim.test(this.text);
    }
    /**
     * Returns `true` if the Cluster does not have Hebrew chars
     *
     * ```typescript
     * * const text: Text = new Text("(??????????????)");
     * text.clusters[0].isNotHebrew;
     * // true
     * ```
     */
    get isNotHebrew() {
        return !/[\u{0590}-\u{05FF}\u{FB1D}-\u{FB4F}]/u.test(this.text);
    }
}
exports.Cluster = Cluster;
_Cluster_original = new WeakMap(), _Cluster_sequenced = new WeakMap();
//# sourceMappingURL=cluster.js.map

