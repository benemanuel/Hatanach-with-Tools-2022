"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syllabify = exports.makeClusters = void 0;
const cluster_1 = require("../cluster");
const syllable_1 = require("../syllable");
/**
 * @description creates a new Syllable, pushes to results[], and resets syl[]
 */
const createNewSyllable = (result, syl, isClosed) => {
    isClosed = isClosed || false;
    const syllable = new syllable_1.Syllable(syl, { isClosed });
    result.push(syllable);
    return [];
};
/**
 * @description determines the Cluster[] that will become the final Syllable
 */
const groupFinal = (arr) => {
    // grouping the final first helps to avoid issues with final kafs/tavs
    const len = arr.length;
    let i = 0;
    const syl = [];
    let result = [];
    let vowelPresent = false;
    let isClosed = false;
    // get final cluster and push to syl
    // but first check if final cluster is not Hebrew
    const finalCluster = arr[i];
    syl.unshift(finalCluster);
    if (finalCluster.hasVowel) {
        // check if finalCluster is syllable
        vowelPresent = true;
        i++;
    }
    else if (finalCluster.isShureq) {
        // check if final cluster isShureq and get preceding Cluster
        i++;
        if (i <= len) {
            syl.unshift(arr[i]);
        }
        vowelPresent = true;
        i++;
    }
    else {
        isClosed = !finalCluster.isMater;
        i++;
    }
    while (!vowelPresent) {
        const nxt = arr[i];
        const curr = nxt ? nxt : false;
        if (!curr) {
            break;
        }
        syl.unshift(curr);
        if (curr.isShureq) {
            i++;
            syl.unshift(arr[i]);
            vowelPresent = true;
        }
        else {
            const clusterHasVowel = "hasVowel" in curr ? curr.hasVowel : true;
            vowelPresent = clusterHasVowel || curr.isShureq;
        }
        i++;
        if (i > len) {
            break;
        }
    }
    const finalSyllable = new syllable_1.Syllable(syl, { isClosed });
    const remainder = arr.slice(i);
    result = remainder.length ? remainder : [];
    result.unshift(finalSyllable);
    return result;
};
/**
 * @description groups shewas either by themselves or with preceding short vowel
 */
const groupShewas = (arr, options) => {
    let shewaPresent = false;
    let syl = [];
    const result = [];
    const len = arr.length;
    const shewaNewSyllable = createNewSyllable.bind(groupShewas, result);
    for (let index = 0; index < len; index++) {
        const cluster = arr[index];
        // skip if already a syllable
        if (cluster instanceof syllable_1.Syllable) {
            result.push(cluster);
            continue;
        }
        const clusterHasShewa = cluster.hasShewa;
        if (!shewaPresent && clusterHasShewa) {
            shewaPresent = true;
            syl.unshift(cluster);
            continue;
        }
        if (shewaPresent && clusterHasShewa) {
            syl = shewaNewSyllable(syl);
            syl.unshift(cluster);
            continue;
        }
        if (shewaPresent && cluster.hasShortVowel) {
            if (cluster.hasMetheg) {
                syl = shewaNewSyllable(syl);
                syl.unshift(cluster);
                continue;
            }
            const dageshRegx = /\u{05BC}/u;
            const prev = syl[0].text;
            const sqenemlevy = /[??????????????????]/;
            const wawConsecutive = /????/;
            // check if there is a doubling dagesh
            if (dageshRegx.test(prev)) {
                syl = shewaNewSyllable(syl);
            }
            // check for waw-consecutive w/ sqenemlevy letter
            else if (options.sqnmlvy && sqenemlevy.test(prev) && wawConsecutive.test(cluster.text)) {
                syl = shewaNewSyllable(syl);
                result.push(new syllable_1.Syllable([cluster]));
                shewaPresent = false;
                continue;
            }
            // check for article preceding yod w/ shewa
            else if (options.article && /[??????]/.test(prev) && /????/.test(cluster.text)) {
                syl = shewaNewSyllable(syl);
                result.push(new syllable_1.Syllable([cluster]));
                shewaPresent = false;
                continue;
            }
            syl.unshift(cluster);
            syl = shewaNewSyllable(syl, true);
            shewaPresent = false;
            continue;
        }
        if (shewaPresent && cluster.hasLongVowel) {
            if (options.longVowels) {
                syl = shewaNewSyllable(syl);
                result.push(cluster);
                shewaPresent = false;
            }
            else {
                syl.unshift(cluster);
                syl = shewaNewSyllable(syl, true);
                shewaPresent = false;
            }
            continue;
        }
        if (shewaPresent && cluster.isShureq) {
            if (!options.wawShureq && !cluster.hasMetheg && len - 1 === index) {
                syl.unshift(cluster);
                syl = shewaNewSyllable(syl, true);
            }
            else {
                syl = shewaNewSyllable(syl);
                result.push(cluster);
                shewaPresent = false;
            }
            continue;
        }
        if (shewaPresent && cluster.isMater) {
            syl = shewaNewSyllable(syl);
            result.push(cluster);
            shewaPresent = false;
            continue;
        }
        if (shewaPresent && !cluster.hasVowel) {
            syl.unshift(cluster);
            continue;
        }
        result.push(cluster);
    }
    if (syl.length) {
        shewaNewSyllable(syl);
    }
    return result;
};
/**
 * @description groups non-final maters with preceding cluster
 */
const groupMaters = (arr) => {
    const len = arr.length;
    let syl = [];
    const result = [];
    const materNewSyllable = createNewSyllable.bind(groupMaters, result);
    for (let index = 0; index < len; index++) {
        const cluster = arr[index];
        if (cluster instanceof syllable_1.Syllable) {
            result.push(cluster);
            continue;
        }
        if (cluster.isMater) {
            syl.unshift(cluster);
            const nxt = arr[index + 1];
            if (nxt instanceof syllable_1.Syllable) {
                throw new Error("Syllable should not precede a Cluster with a Mater");
            }
            syl.unshift(nxt);
            syl = materNewSyllable(syl);
            index++;
        }
        // check for quiesced alef ??? not a mater, but similar
        else if (!cluster.hasVowel && /??/.test(cluster.text)) {
            syl.unshift(cluster);
            const nxt = arr[index + 1];
            // at this point, only final syllables and shewas are Syllables
            if (nxt instanceof syllable_1.Syllable) {
                result.push(cluster);
                continue;
            }
            syl.unshift(nxt);
            syl = materNewSyllable(syl);
            index++;
        }
        else {
            result.push(cluster);
        }
    }
    return result;
};
/**
 * @description groups non-final shureqs with preceding cluster
 */
const groupShureqs = (arr) => {
    const len = arr.length;
    let syl = [];
    const result = [];
    const shureqNewSyllable = createNewSyllable.bind(groupShureqs, result);
    for (let index = 0; index < len; index++) {
        const cluster = arr[index];
        if (cluster instanceof syllable_1.Syllable) {
            result.push(cluster);
            continue;
        }
        if (cluster.isShureq) {
            syl.unshift(cluster);
            const nxt = arr[index + 1];
            if (nxt instanceof syllable_1.Syllable) {
                throw new Error("Syllable should not precede a Cluster with a Mater");
            }
            if (nxt !== undefined) {
                syl.unshift(nxt);
            }
            syl = shureqNewSyllable(syl);
            index++;
        }
        else {
            result.push(cluster);
        }
    }
    return result;
};
/**
 * @description a preprocessing step that groups clusters into intermediate syllables by vowels or shewas
 */
const groupClusters = (arr, options) => {
    const rev = arr.reverse();
    const finalGrouped = groupFinal(rev);
    const shewasGrouped = groupShewas(finalGrouped, options);
    const shureqGroups = groupShureqs(shewasGrouped);
    const matersGroups = groupMaters(shureqGroups);
    const result = matersGroups.reverse();
    return result;
};
/**
 *
 * @param word the word to be split into Cluster
 * @description splits a word at each consonant or the punctuation character
 * Sof Pasuq and Nun Hafukha
 */
const makeClusters = (word) => {
    const split = /(?=[\u{05C3}\u{05C6}\u{05D0}-\u{05F2}\u{2000}-\u{206F}\u{2E00}-\u{2E7F}'!"#$%&()*+,-.\/:;<=>?@\[\]^_`\{|\}~])/u;
    const groups = word.split(split);
    const clusters = groups.map((group) => new cluster_1.Cluster(group));
    return clusters;
};
exports.makeClusters = makeClusters;
const setIsClosed = (syllable, index, arr) => {
    // no need to check, groupFinal takes care of it
    if (index === arr.length - 1) {
        return syllable;
    }
    if (!syllable.isClosed) {
        const dageshRegx = /\u{05BC}/u;
        const hasShortVowel = !!syllable.clusters.filter((cluster) => cluster.hasShortVowel).length;
        /**
         * if `hasShortVowel` is true, nothing to check;
         * if a syllable has only one cluster with a shewa, then it is false;
         * else, it means the preceding cluster has no vowel
         */
        const hasNoVowel = hasShortVowel || !!(syllable.clusters.filter((cluster) => !cluster.hasVowel).length - 1);
        const prev = arr[index + 1];
        const prevDagesh = dageshRegx.test(prev.clusters[0].text);
        syllable.isClosed = (hasShortVowel || hasNoVowel) && prevDagesh;
    }
};
const setIsAccented = (syllable) => {
    const isAccented = syllable.clusters.filter((cluster) => cluster.hasTaamim).length ? true : false;
    syllable.isAccented = isAccented;
};
/**
 *
 * @description a step to get a Cluster's original position before filtering out latin
 */
const clusterPos = (cluster, i) => {
    return { cluster, pos: i };
};
const reinsertLatin = (syls, latin) => {
    const numOfSyls = syls.length;
    for (let index = 0; index < latin.length; index++) {
        const group = latin[index];
        const partial = [];
        // if a latin cluster was at the beginning
        if (group.pos === 0) {
            partial.push(group.cluster);
            while (index + 1 < latin.length && latin[index + 1].pos === group.pos + 1) {
                partial.push(latin[index + 1].cluster);
                index++;
            }
            const firstSyl = syls[0];
            syls[0] = new syllable_1.Syllable([...partial, ...firstSyl.clusters], {
                isClosed: firstSyl.isClosed,
                isAccented: firstSyl.isAccented,
                isFinal: firstSyl.isFinal
            });
        }
        else {
            const lastSyl = syls[numOfSyls - 1];
            while (index < latin.length) {
                partial.push(latin[index].cluster);
                index++;
            }
            syls[numOfSyls - 1] = new syllable_1.Syllable([...lastSyl.clusters, ...partial], {
                isClosed: lastSyl.isClosed,
                isAccented: lastSyl.isAccented,
                isFinal: lastSyl.isFinal
            });
        }
    }
    return syls;
};
const syllabify = (clusters, options) => {
    const removeLatin = clusters.filter((cluster) => !cluster.isNotHebrew);
    const latinClusters = clusters.map(clusterPos).filter((c) => c.cluster.isNotHebrew);
    const groupedClusters = groupClusters(removeLatin, options);
    const syllables = groupedClusters.map((group) => (group instanceof syllable_1.Syllable ? group : new syllable_1.Syllable([group])));
    syllables.forEach((syllable, index, arr) => setIsClosed(syllable, index, arr));
    syllables.forEach((syllable) => setIsAccented(syllable));
    syllables[syllables.length - 1].isFinal = true;
    return latinClusters.length ? reinsertLatin(syllables, latinClusters) : syllables;
};
exports.syllabify = syllabify;
//# sourceMappingURL=syllabifier.js.map

